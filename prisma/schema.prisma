generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model characters {
  id                  Int                @id @default(autoincrement())
  name                String
  description         String?
  systemTemplate      String?
  firstSituation      String?
  firstMessage        String?
  visibility          String?
  safetyFilter        Boolean?
  category            String?
  hashtags            String[]
  detailSetting       String?
  author_id           Int?
  createdAt           DateTime           @default(now()) @db.Timestamptz(6)
  updatedAt           DateTime           @default(now()) @updatedAt @db.Timestamptz(6)
  firstSituationDate  DateTime?          @db.Timestamptz(6)
  firstSituationPlace String?
  characterImages     character_images[]
  author              users?             @relation(fields: [author_id], references: [id])
  chat                chat[]
  comments            comments[]
  embeddings          embeddings[]
  favorites           favorites[]
  interactions        interactions[]
  lorebooks           lorebooks[]
}

model users {
  id                            Int            @id @default(autoincrement())
  email                         String         @unique
  password                      String?
  name                          String
  phone                         String?        @unique
  nickname                      String         @unique
  created_at                    DateTime?      @default(now()) @db.Timestamp(6)
  image_url                     String?
  bio                           String?
  safetyFilter                  Boolean        @default(true)
  defaultPersonaId              Int?
  role                          Role           @default(USER)
  emailVerified                 DateTime?
  suspendedUntil                DateTime? // ユーザー停止期限
  suspensionReason              String? // 停止理由
  accounts                      Account[]      @relation("UserAccounts")
  Block_Block_blockerIdTousers  Block[]        @relation("Block_blockerIdTousers")
  Block_Block_blockingIdTousers Block[]        @relation("Block_blockingIdTousers")
  sessions                      Session[]      @relation("UserSessions")
  characters                    characters[]
  chat                          chat[]
  comments                      comments[]
  favorites                     favorites[]
  following                     follows[]      @relation("follower")
  followers                     follows[]      @relation("following")
  interactions                  interactions[]
  personas                      personas[]
  points                        points?
  // ▼▼▼【修正】エラーを引き起こす重複した'sessions'フィールドを削除しました。▼▼▼
}

model character_images {
  id           Int        @id @default(autoincrement())
  imageUrl     String
  keyword      String?
  isMain       Boolean    @default(false)
  displayOrder Int        @default(0)
  createdAt    DateTime?  @default(now()) @db.Timestamptz(6)
  characterId  Int
  character    characters @relation(fields: [characterId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_character")
}

model favorites {
  id           Int         @id @default(autoincrement())
  user_id      Int?
  character_id Int?
  created_at   DateTime?   @default(now()) @db.Timestamp(6)
  characters   characters? @relation(fields: [character_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  users        users?      @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([user_id, character_id])
}

model interactions {
  id           Int         @id @default(autoincrement())
  user_id      Int?
  character_id Int?
  message      String
  is_user      Boolean
  created_at   DateTime?   @default(now()) @db.Timestamp(6)
  characters   characters? @relation(fields: [character_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  users        users?      @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model points {
  id             Int       @id @default(autoincrement())
  user_id        Int       @unique
  free_points    Int       @default(0)
  paid_points    Int       @default(0)
  updated_at     DateTime  @default(now())
  lastAttendedAt DateTime? @db.Timestamptz(6)
  users          users     @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model chat {
  id                  Int                 @id @default(autoincrement())
  userId              Int
  characterId         Int
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  userNote            String?
  backMemory          String?             @db.Text
  backMemoryEmbedding Unsupported("vector")?
  autoSummarize       Boolean             @default(true)
  characters          characters          @relation(fields: [characterId], references: [id], onDelete: Cascade)
  users               users               @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat_message        chat_message[]
  detailed_memories   detailed_memories[]

  // Note: backMemoryEmbedding index is created manually via SQL (ivfflat)
  // @@index([backMemoryEmbedding]) - removed to use ivfflat index
}

model chat_message {
  id        Int      @id @default(autoincrement())
  chatId    Int
  role      String   @db.VarChar(255)
  content   String
  createdAt DateTime @default(now())
  turnId    Int?
  version   Int      @default(1)
  isActive  Boolean  @default(true)
  embedding Unsupported("vector")?
  chat      chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId, turnId, isActive])
  @@index([chatId, isActive, createdAt], map: "chat_message_chatId_isActive_createdAt_idx")
  // Note: embedding index is created manually via SQL (ivfflat)
  // @@index([embedding]) - removed to use ivfflat index
}

model follows {
  followerId  Int
  followingId Int
  follower    users @relation("follower", fields: [followerId], references: [id])
  following   users @relation("following", fields: [followingId], references: [id])

  @@id([followerId, followingId])
}

model personas {
  id          Int      @id @default(autoincrement())
  nickname    String   @db.VarChar(20)
  age         Int?
  gender      String?  @db.VarChar(255)
  description String   @db.VarChar(1000)
  createdAt   DateTime @default(now())
  authorId    Int
  users       users    @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([authorId])
}

model notices {
  id        Int      @id @default(autoincrement())
  category  String   @db.VarChar(50)
  title     String   @db.VarChar(255)
  content   String
  createdAt DateTime @default(now()) @db.Timestamp(6)
}

model guides {
  id           Int      @id @default(autoincrement())
  mainCategory String   @db.VarChar(100)
  subCategory  String   @db.VarChar(100)
  title        String   @db.VarChar(255)
  content      String
  displayOrder Int      @default(0)
  createdAt    DateTime @default(now()) @db.Timestamptz(6)

  @@index([mainCategory, subCategory])
}

model lorebooks {
  id          Int                    @id @default(autoincrement())
  content     String
  keywords    String[]
  characterId Int
  embedding   Unsupported("vector")?
  characters  characters             @relation(fields: [characterId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([embedding])
}

model comments {
  id             Int        @id @default(autoincrement())
  content        String
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  characterId    Int
  authorId       Int
  parentId       Int?
  users          users      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  characters     characters @relation(fields: [characterId], references: [id], onDelete: Cascade)
  comments       comments?  @relation("commentsTocomments", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  other_comments comments[] @relation("commentsTocomments")

  @@index([authorId])
  @@index([characterId])
}

model Block {
  blockerId                     Int
  blockingId                    Int
  createdAt                     DateTime @default(now())
  users_Block_blockerIdTousers  users    @relation("Block_blockerIdTousers", fields: [blockerId], references: [id], onDelete: Cascade)
  users_Block_blockingIdTousers users    @relation("Block_blockingIdTousers", fields: [blockingId], references: [id], onDelete: Cascade)

  @@id([blockerId, blockingId])
}

model Account {
  id                Int     @id @default(autoincrement())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              users   @relation("UserAccounts", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           Int      @id @default(autoincrement())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         users    @relation("UserSessions", fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model embeddings {
  id           Int                    @id @default(autoincrement())
  character_id Int?
  content      String?
  embedding    Unsupported("vector")?
  characters   characters?            @relation(fields: [character_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([embedding])
  @@index([embedding], map: "embeddings_embedding_idx1")
}

model detailed_memories {
  id          Int       @id @default(autoincrement())
  chatId      Int
  content     String    @db.Text
  keywords    String[] // キーワード配列
  embedding   Unsupported("vector")?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastApplied DateTime? // 最後に適用された時刻
  chat        chat      @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId, createdAt])
  // Note: embedding index is created manually via SQL (ivfflat)
  // @@index([embedding]) - removed to use ivfflat index
}

// ▼▼▼【修正】不要で重複エラーを引き起こす'sessions'モデルを削除しました。▼▼▼

enum Role {
  USER
  MODERATOR
  CHAR_MANAGER
  SUPER_ADMIN
}

export const runtime = "nodejs";export const dynamic = "force-dynamic"; // ?¼â–¼?¼ã€é‡è¦ã€‘ã‚­?£ãƒƒ?·ãƒ¥?’ç„¡?¹åŒ–?—ã¦å¸¸ã«?€?°ãƒ‡?¼ã‚¿?’å–å¾??¼â–¼??import { NextResponse } from "next/server";import { prisma } from "@/lib/prisma";import {  VertexAI,  HarmCategory,  HarmBlockThreshold,  Content,} from "@google-cloud/vertexai";import { getServerSession } from "next-auth";import { authOptions } from "@/lib/nextauth";import { getEmbedding } from "@/lib/embeddings";import { searchSimilarMessages, searchSimilarDetailedMemories } from "@/lib/vector-search";import { getSafetySettings } from "@/lib/chat/safety-settings";import { CharacterImageInfo, selectImageByKeyword, addImageTagIfKeywordMatched } from "@/lib/chat/image-selection";import { extractKeywords } from "@/lib/chat/keyword-extraction";import { createDetailedMemories, updateMemoriesWithAIKeywords } from "@/lib/chat/memory-management";// VertexAI??ƒ©?¤ã‚¢?³ãƒˆ??ˆ?ŸåŒ–const vertex_ai = new VertexAI({  project: process.env.GOOGLE_PROJECT_ID,  location: "asia-northeast1",});// eslint-disable-next-line @typescript-eslint/no-explicit-anyexport async function POST(request: Request, context: any) {Â  console.log("?ãƒ£?ƒãƒˆAPI?ªã‚¯?¨ã‚¹?ˆå—ä¿?);Â  console.time("?±ï¸ ?¨ä½“API??†?‚é–“"); // ?¨ä½“?‚é–“æ¸¬å®š?‹å§‹Â  const { params } = (context ?? {}) as { params?: Record<string, string | string[]> };Â  const rawChatId = params?.chatId;Â  const chatIdStr = Array.isArray(rawChatId) ? rawChatId[0] : rawChatId;Â  const session = await getServerSession(authOptions);Â  if (!session || !session.user?.id) {Â  Â  console.timeEnd("?±ï¸ ?¨ä½“API??†?‚é–“");Â  Â  return NextResponse.json({ message: "èªè¨¼?Œå¿…è¦ã§?™ã€? }, { status: 401 });Â  }  const chatId = parseInt(String(chatIdStr), 10);  if (isNaN(chatId)) {    console.timeEnd("?±ï¸ ?¨ä½“API??†?‚é–“");    return NextResponse.json({ message: "?¡åŠ¹?ªãƒ?£ãƒƒ?ˆID?§ã™?? }, { status: 400 });  }  const userId = parseInt(String(session.user.id), 10);  // ?¼â–¼?¼ã€è¿½? ã€‘ãƒ¦?¼ã‚¶?¼ã®?»ãƒ¼?•ãƒ†?£ãƒ•?£ãƒ«?¿ãƒ¼è¨?®š?’å–å¾?  const user = await prisma.users.findUnique({    where: { id: userId },    select: { safetyFilter: true },  });  const userSafetyFilter = user?.safetyFilter ?? true; // ?‡ãƒ•?©ãƒ«?ˆã¯trueï¼ˆãƒ•?£ãƒ«?¿ãƒ¼ONï¼?  // ?²â–²??  const { message, settings, isRegeneration, turnId, activeVersions } = await request.json();  if (!message) {    console.timeEnd("?±ï¸ ?¨ä½“API??†?‚é–“");    return NextResponse.json({ message: "?¡ãƒƒ?»ãƒ¼?¸ã¯å¿…é ˆ?§ã™?? }, { status: 400 });  }Â  try {Â  Â  // DB?¸ãè¾¼ã¿Promise (?ã‚¤?³ãƒˆæ¶ˆè²», ?¡ãƒƒ?»ãƒ¼?¸ä¿å­?Â  Â  const dbWritePromise = (async () => {Â  Â  Â  console.time("?±ï¸ DB Write (Points+Msg)");Â  Â  Â  console.log(`?¹ãƒ†?ƒãƒ—1: ?ã‚¤?³ãƒˆæ¶ˆè²»?¨ãƒ¡?ƒã‚»?¼ã‚¸ä¿å­˜??†?‹å§‹ (?¦ãƒ¼?¶ãƒ¼ID: ${userId})`);Â  Â  Â  const totalPointsToConsume = 1;Â  Â  Â  let userMessageForHistory;Â  Â  Â  let turnIdForModel;Â  Â  Â  if (isRegeneration && turnId) {Â  Â  Â  Â  console.log(`?¹ãƒ†?ƒãƒ—3: ?ç”Ÿ?ã®?ªã‚¯?¨ã‚¹?ˆã‚’??† (?¿ãƒ¼?³ID: ${turnId})`);Â  Â  Â  Â  await prisma.$transaction(async (tx) => {Â  Â  Â  Â  Â  Â  const p = await tx.points.findUnique({ where: { user_id: userId } });Â  Â  Â  Â  Â  Â  const currentPoints = (p?.free_points || 0) + (p?.paid_points || 0);Â  Â  Â  Â  Â  Â  if (currentPoints < totalPointsToConsume) throw new Error("?ã‚¤?³ãƒˆ?Œä¸è¶³ã—?¦ã„?¾ã™??);Â  Â  Â  Â  Â  Â  let cost = totalPointsToConsume;Â  Â  Â  Â  Â  Â  const freeAfter = Math.max(0, (p?.free_points || 0) - cost);Â  Â  Â  Â  Â  Â  cost = Math.max(0, cost - (p?.free_points || 0));Â  Â  Â  Â  Â  Â  const paidAfter = Math.max(0, (p?.paid_points || 0) - cost);Â  Â  Â  Â  Â  Â  await tx.points.update({ where: { user_id: userId }, data: { free_points: freeAfter, paid_points: paidAfter } });Â  Â  Â  Â  });Â  Â  Â  Â  userMessageForHistory = await prisma.chat_message.findUnique({ where: { id: turnId }});Â  Â  Â  Â  if (!userMessageForHistory || userMessageForHistory.role !== 'user') throw new Error("?ç”Ÿ?å?è±¡ã®?¡ãƒƒ?»ãƒ¼?¸ãŒè¦‹ã¤?‹ã‚Š?¾ã›?“ã€?);Â  Â  Â  Â  turnIdForModel = userMessageForHistory.id;Â  Â  Â  } else {Â  Â  Â  Â  console.log("?¹ãƒ†?ƒãƒ—3: ?°è¦?¦ãƒ¼?¶ãƒ¼?¡ãƒƒ?»ãƒ¼?¸ä¿å­˜é–‹å§?);Â  Â  Â  Â  userMessageForHistory = await prisma.$transaction(async (tx) => {Â  Â  Â  Â  Â  Â  const p = await tx.points.findUnique({ where: { user_id: userId } });Â  Â  Â  Â  Â  Â  const currentPoints = (p?.free_points || 0) + (p?.paid_points || 0);Â  Â  Â  Â  Â  Â  if (currentPoints < totalPointsToConsume) throw new Error("?ã‚¤?³ãƒˆ?Œä¸è¶³ã—?¦ã„?¾ã™??);Â  Â  Â  Â  Â  Â  let cost = totalPointsToConsume;Â  Â  Â  Â  Â  Â  const freeAfter = Math.max(0, (p?.free_points || 0) - cost);Â  Â  Â  Â  Â  Â  cost = Math.max(0, cost - (p?.free_points || 0));Â  Â  Â  Â  Â  Â  const paidAfter = Math.max(0, (p?.paid_points || 0) - cost);Â  Â  Â  Â  Â  Â  await tx.points.update({ where: { user_id: userId }, data: { free_points: freeAfter, paid_points: paidAfter } });             const newUserMessage = await tx.chat_message.create({ data: { chatId: chatId, role: "user", content: message, version: 1, isActive: true } });             const updatedMessage = await tx.chat_message.update({ where: { id: newUserMessage.id }, data: { turnId: newUserMessage.id } });             // ?¼â–¼?¼ã€ãƒ™??ƒˆ?«æ¤œç´¢ã€‘ãƒ¡?ƒã‚»?¼ã‚¸?®embedding?’é?ŒæœŸ?§ç”Ÿ?ï¼ˆå¿œç­”?Ÿåº¦?’ç¶­?ï¼‰?¼â–¼??             (async () => {               try {                 const embedding = await getEmbedding(message);                 const embeddingString = `[${embedding.join(',')}]`;                 await prisma.$executeRawUnsafe(                   `UPDATE "chat_message" SET "embedding" = $1::vector WHERE "id" = $2`,                   embeddingString,                   newUserMessage.id                 );               } catch (error) {                 console.error('?¡ãƒƒ?»ãƒ¼?¸embedding?Ÿæˆ?¨ãƒ©??', error);               }             })();             // ?²â–²??             return updatedMessage;Â  Â  Â  Â  });Â  Â  Â  Â  turnIdForModel = userMessageForHistory.id;Â  Â  Â  Â  console.log("?¹ãƒ†?ƒãƒ—3: ?¦ãƒ¼?¶ãƒ¼?¡ãƒƒ?»ãƒ¼?¸ä¿å­˜å®Œäº?);Â  Â  Â  }Â  Â  Â  console.timeEnd("?±ï¸ DB Write (Points+Msg)");Â  Â  Â  return { userMessageForHistory, turnIdForModel };Â  Â  })();Â  Â  // ?³ãƒ³?†ã‚­?¹ãƒˆ?–å¾—Promise (DB??‚¨?ªã®??Â  Â  const contextPromise = (async () => {Â  Â  Â  Â  console.time("?±ï¸ Context Fetch Total (DB Only)");Â  Â  Â  Â  console.log(`?¹ãƒ†?ƒãƒ—2: ?ãƒ£?ƒãƒˆ?«ãƒ¼? ã¨ä¸–ç•Œè¦³ï¼ˆcharactersï¼‰æƒ…?±å–å¾?(?ãƒ£?ƒãƒˆID: ${chatId})`);Â  Â  Â  Â  console.time("?±ï¸ DB ChatRoom+Lorebooks Query");Â  Â  Â  Â  // 'characters' ??¸–?Œè¦³?„ã‚·?Šãƒª?ªè¨­å®šã‚’ä¿æŒ?™ã‚‹?¨ãƒ³?†ã‚£?†ã‚£?¨ã—??‰±??Â  Â  Â  Â  const chatRoom = await prisma.chat.findUnique({Â  Â  Â  Â  Â  Â  where: { id: chatId },Â  Â  Â  Â  Â  Â  include: {Â  Â  Â  Â  Â  Â  Â  Â  characters: { // 'characters' ?†ãƒ¼?–ãƒ«?«ã¯ä¸–ç•Œè¦³ãƒ»?·ãƒŠ?ªã‚ªè¨?®š?Œå«?¾ã‚Œ??Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  include: {Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lorebooks: { orderBy: { id: "asc" } },Â  Â  Â                    characterImages: { orderBy: { id: "asc" } }, // id?§ã‚½?¼ãƒˆÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  },Â  Â  Â  Â  Â  Â  Â  Â  },Â  Â  Â  Â  Â  Â  Â  Â  users: { select: { defaultPersonaId: true, nickname: true } },Â  Â  Â  Â  Â  Â  },Â  Â  Â  Â  });Â  Â  Â  Â  console.timeEnd("?±ï¸ DB ChatRoom+Lorebooks Query");        if (!chatRoom || !chatRoom.characters) {            throw new Error("?ãƒ£?ƒãƒˆ?¾ãŸ??¸–?Œè¦³ï¼ˆcharactersï¼‰è¨­å®šãŒè¦‹ã¤?‹ã‚Š?¾ã›?“ã€?);        }        // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘chatRoom?…å ±?’ãƒ­?°å‡º???¼â–¼??        console.log("?¹ãƒ†?ƒãƒ—2: ?ãƒ£?ƒãƒˆ?«ãƒ¼? æƒ…?±å–å¾—å®Œäº?);        console.log(`chatRoom.id: ${chatRoom.id}`);        console.log(`chatRoom.characters.id: ${chatRoom.characters?.id}`);        console.log(`chatRoom.characters.name: ${chatRoom.characters?.name}`);        console.log(`chatRoom.characters.systemTemplate length: ${chatRoom.characters?.systemTemplate?.length || 0}`);        console.log(`chatRoom.characters.characterImages count: ${chatRoom.characters?.characterImages?.length || 0}`);        if (!chatRoom.characters.systemTemplate || chatRoom.characters.systemTemplate.trim().length === 0) {          console.error(`? ï¸ WARNING: characters.systemTemplate is empty or missing! (Character ID: ${chatRoom.characters?.id}, Name: ${chatRoom.characters?.name || 'Unknown'})`);          console.error(`? ï¸ This may affect AI response quality. Please check the character's systemTemplate in the database.`);        }        // ?²â–²??Â  Â  Â  Â  console.time("?±ï¸ DB History+Persona Query");        // ?¼â–¼?¼ã€ä¿®æ­£ã€‘ãƒ¦?¼ã‚¶?¼ãŒ?²è¦§?—ã¦?„ã‚‹?ãƒ¼?¸ãƒ§?³ã‚’?ƒæ…®?—ãŸå±¥æ??–å¾— ?¼â–¼??        // ?¾åœ¨??ƒ¡?ƒã‚»?¼ã‚¸(userMessageForHistory)?ˆã‚Š?ã®?¡ãƒƒ?»ãƒ¼?¸ã®?¿ã‚’?–å¾—        // æ³¨æ„: userMessageForHistory??¾? å–å¾—ã•?Œã¦?„ãª?„ãŸ?ã€createdAt?§åˆ¶??        let historyWhereClause: {            chatId: number;            createdAt?: { lt: Date };            isActive?: boolean;            OR?: Array<{ role: string } | { id: { in: number[] } }>;        } = {             chatId: chatId            // createdAt?¶é™?’å‰Š?? ä¸?ˆ—??†??Ÿ?ã€ç¾?¨ã®?¡ãƒƒ?»ãƒ¼?¸ã¯?¾ã ä¿å­˜?•ã‚Œ?¦ã„?ªã„        };                // activeVersions?ŒæŒ‡å®šã•?Œã¦?„ã‚‹?´åˆ?è©²å½“ãƒ?¼ã‚¸?§ãƒ³??¿?’å–å¾?        if (activeVersions && Object.keys(activeVersions).length > 0) {            // ?¼â–¼?¼ã€ä¿®æ­£ã€‘INT4ç¯„å›²?’è¶…?ˆã‚‹?¤ï¼ˆDate.now()?§ç”Ÿ?ã•?ŒãŸä¸€?‚IDï¼‰ã‚’?•ã‚£?«ã‚¿?ªãƒ³???¼â–¼??            const MAX_INT4 = 2147483647; // INT4???å¤§å€?            const versionIds = Object.values(activeVersions)                .map(id => Number(id))                .filter(id => id > 0 && id <= MAX_INT4); // ?‰åŠ¹?ªINT4ç¯„å›²?…ã®ID??¿                        // ?‰åŠ¹?ªID?Œã‚?‹å ´?ˆã®?¿ç‰¹?¥ãª??‚¨?ªã‚’ä½¿ç”¨            if (versionIds.length > 0) {                historyWhereClause = {                    chatId: chatId,                    createdAt: { lt: new Date() },                    OR: [                        { role: 'user' },  // ?¦ãƒ¼?¶ãƒ¼?¡ãƒƒ?»ãƒ¼?¸ã¯?¨ã¦?«ã‚??                        { id: { in: versionIds } }  // ?‡å®š?•ã‚Œ?Ÿãƒ?¼ã‚¸?§ãƒ³??ƒ¢?‡ãƒ«?¡ãƒƒ?»ãƒ¼??                    ]                };            } else {                // ?‰åŠ¹?ªID?Œãª?„å ´?ˆã¯?šå¸¸?®isActive=true??¿                historyWhereClause.isActive = true;            }            // ?²â–²??        } else {            // ?šå¸¸?¯isActive=true??ƒ¡?ƒã‚»?¼ã‚¸??¿            historyWhereClause.isActive = true;        }        // ?²â–²?²ã€ä¿®æ­£å®Œäº†ã€‘â–²?²â–²        const [persona, history, backMemory, detailedMemories] = await Promise.all([            chatRoom.users.defaultPersonaId ? prisma.personas.findUnique({ where: { id: chatRoom.users.defaultPersonaId } }) : Promise.resolve(null),            prisma.chat_message.findMany({                where: historyWhereClause,                orderBy: { createdAt: "desc" },                take: 10, // å±¥æ??????0ä»¶ã‚’?–å¾—ï¼ˆç¢ºå®Ÿã«?¨ã¦??†…å®¹ã‚’èª?¿?–ã‚‹ï¼?            }),            prisma.chat.findUnique({                where: { id: chatId },                select: { backMemory: true, autoSummarize: true },            }),            prisma.detailed_memories.findMany({                where: { chatId: chatId },                orderBy: { createdAt: "asc" }, // ?†ç•ª?šã‚Š?«é©?¨ã™?‹ãŸ?æ˜‡??            }),        ]);                console.timeEnd("?±ï¸ DB History+Persona Query");        const orderedHistory = history.reverse();                // ?¼â–¼?¼ã€ãƒ™??ƒˆ?«æ¤œç´¢ã€‘æ???0ä»¶ã«? ãˆ?¦ã€é–¢?£ãƒ¡?ƒã‚»?¼ã‚¸?’ãƒ™??ƒˆ?«æ¤œç´¢ã§è¿½åŠ ï¼ˆé?ŒæœŸ?ã‚ª?—ã‚·?§ãƒ³ï¼‰â–¼?¼â–¼        // ?™ã‚¯?ˆãƒ«æ¤œç´¢??™‚?“ãŒ?‹ã‹?‹ãŸ?ã€ãƒ¡?¤ãƒ³??†?’ãƒ–??ƒƒ??—?ªã„?ˆã†?«é?ŒæœŸ?§å®Ÿè¡?        // ?¨ãƒ©?¼ãŒ?ºç”Ÿ?—ã¦?‚ãƒ?£ãƒƒ?ˆã¯ç¶šè¡Œ??ƒ½        // ?€?ã®?¡ãƒƒ?»ãƒ¼?¸ï¼ˆå±¥æ???ä»¶ä»¥ä¸‹ï¼‰?? ´?ˆã¯?¹ã‚­?ƒãƒ—?—ã¦é«˜é€ŸåŒ–        let vectorMatchedMessages: Array<{ id: number; content: string; role: string; createdAt: Date }> = [];        if (orderedHistory.length > 1) {          // 2ä»¶ä»¥ä¸Šã®?¡ãƒƒ?»ãƒ¼?¸ãŒ?‚ã‚‹?´åˆ??¿?™ã‚¯?ˆãƒ«æ¤œç´¢?’å®Ÿè¡?          const vectorSearchPromise = (async () => {            try {              const messageEmbedding = await getEmbedding(message);              const excludeTurnIds = orderedHistory.map(msg => msg.turnId || 0).filter(id => id > 0);              const matched = await searchSimilarMessages(messageEmbedding, chatId, excludeTurnIds, 10); // 5ä»¶ã‹??0ä»¶ã«å¢—åŠ               return matched;            } catch (error) {              console.error('?™ã‚¯?ˆãƒ«æ¤œç´¢?¨ãƒ©?¼ï¼ˆ?¡ãƒƒ?»ãƒ¼?¸ï¼‰:', error);              return [];            }          })();                    // ?™ã‚¯?ˆãƒ«æ¤œç´¢çµæœ??¾Œ?§ä½¿?¨ï¼ˆ?åŒ?Ÿã§å¾…æ©Ÿ?ã‚¿?¤ãƒ ?¢ã‚¦?ˆä»˜?ï¼‰          try {            const matched = await Promise.race([              vectorSearchPromise,              new Promise<[]>(resolve => setTimeout(() => resolve([]), 2000)) // 2ç§’ã‚¿?¤ãƒ ?¢ã‚¦??            ]);            // ?¢å­˜å±¥æ??«å«?¾ã‚Œ?¦ã„?ªã„?¡ãƒƒ?»ãƒ¼?¸ã®?¿è¿½??            const existingIds = new Set(orderedHistory.map(h => h.id));            vectorMatchedMessages = matched.filter(m => !existingIds.has(m.id));          } catch (error) {            // ?™ã‚¯?ˆãƒ«æ¤œç´¢?Œå¤±?—ã—?¦ã‚‚ç¶šè¡Œ            console.error('?™ã‚¯?ˆãƒ«æ¤œç´¢çµæœ?–å¾—?¨ãƒ©??', error);          }        }        // ?²â–²??        console.log("?¹ãƒ†?ƒãƒ—2.5: ?šãƒ«?½ãƒŠ?¨å±¥æ­´ã®?–å¾—å®Œäº†");        console.log(`ä½¿ç”¨?•ã‚Œ?Ÿãƒ?¼ã‚¸?§ãƒ³: ${activeVersions ? JSON.stringify(activeVersions) : '?‡ãƒ•?©ãƒ«??isActive)'}`);        console.timeEnd("?±ï¸ Context Fetch Total (DB Only)");        return { chatRoom, persona, orderedHistory, backMemory, detailedMemories, vectorMatchedMessages };Â  Â  })();Â  Â  // 2?¤ã®ä¸?ˆ—??†?Œå®Œäº†ã™?‹ã®?’å¾…?¡ã¾?™ã€?Â  Â  console.time("?±ï¸ Promise.all(DBWrite, Context)");Â  Â  const [dbWriteResult, contextResult] = await Promise.all([dbWritePromise, contextPromise]);Â  Â  console.timeEnd("?±ï¸ Promise.all(DBWrite, Context)");    const { userMessageForHistory, turnIdForModel } = dbWriteResult;    const { chatRoom, persona, orderedHistory, backMemory, detailedMemories, vectorMatchedMessages } = contextResult;    // ?¼â–¼?¼ã€è¿½? ã€‘ã‚»?¼ãƒ•?†ã‚£?•ã‚£?«ã‚¿?? ?¦ãƒ¼?¶ãƒ¼??‚»?¼ãƒ•?†ã‚£?•ã‚£?«ã‚¿?¼ãŒON?§ã€ã‚­?£ãƒ©??‚¿?¼ã®?»ãƒ¼?•ãƒ†?£ãƒ•?£ãƒ«?¿ãƒ¼?ŒOFF?? ´?ˆã¯?¢ã‚¯?»ã‚¹?’å¦    if (userSafetyFilter && chatRoom.characters.safetyFilter === false) {      console.log(`[POST /api/chat/${chatId}] ?»ãƒ¼?•ãƒ†?£ãƒ•?£ãƒ«?¿ãƒ¼: ?¦ãƒ¼?¶ãƒ¼??ƒ•?£ãƒ«?¿ãƒ¼?ŒON?ã‚­?£ãƒ©??‚¿?¼ã®?•ã‚£?«ã‚¿?¼ãŒOFF??Ÿ?ã‚¢??‚»?¹æ‹’??);      console.timeEnd("?±ï¸ ?¨ä½“API??†?‚é–“");      return NextResponse.json({         message: '?“ã®??ƒ£?©ã‚¯?¿ãƒ¼??‚»?¼ãƒ•?†ã‚£?•ã‚£?«ã‚¿?¼ãŒ?ªãƒ•??Ÿ?ã€ã‚»?¼ãƒ•?†ã‚£?•ã‚£?«ã‚¿?¼ãŒON??Š¶?‹ã§??ƒ?£ãƒƒ?ˆã§?ã¾?›ã‚“??       }, { status: 403 });    }    // ?²â–²??Â  Â  const worldSetting = chatRoom.characters; // 'char' ?‹ã‚‰ 'worldSetting' ?«å¤‰?°å?’å¤‰??(?å‘³?’æ˜ç¢ºåŒ–)Â  Â  const user = chatRoom.users;Â  Â  const worldName = worldSetting.name; // {{char}} ?«ç½®?›ã•?Œã‚‹?å‰ (ä¸–ç•Œè¦³ã®?å‰)Â  Â  const userNickname = persona?.nickname || user.nickname || "?¦ãƒ¼?¶ãƒ¼"; // {{user}} ?«ç½®?›ã•?Œã‚‹?å‰Â  Â  // ?—ãƒ¬?¼ã‚¹?›ãƒ«?€?¼ï¼ˆ{{char}}??{user}}ï¼‰ã‚’ç½?›?™ã‚‹?˜ãƒ«?‘ãƒ¼?¢æ•°Â  Â  const replacePlaceholders = (text: string | null | undefined): string => {Â  Â  Â  if (!text) return "";Â  Â  Â  // {{char}} ?’ä¸–?Œè¦³????(characters.name) ?«ç½®??Â  Â  Â  // {{user}} ?’ãƒ¦?¼ã‚¶?¼ã®?‹ãƒƒ??ƒ?ƒã‚¯ (?šãƒ«?½ãƒŠ?ªå…ˆ) ?«ç½®??Â  Â  Â  return text.replace(/{{char}}/g, worldName).replace(/{{user}}/g, userNickname);Â  Â  };    // AI?¢ãƒ‡?«ã«æ¸¡ã™?ãƒ£?ƒãƒˆå±¥æ??’ä½œ?ï¼ˆ?—ãƒ¬?¼ã‚¹?›ãƒ«?€?¼ã‚’ç½?›ï¼?    // ?€??0ä»?+ ?™ã‚¯?ˆãƒ«æ¤œç´¢?§è¦‹?¤ã‹?£ãŸ??€£ãƒ¡?ƒã‚»?¼ã‚¸?’çµ±??    // ?¾åœ¨??ƒ¡?ƒã‚»?¼ã‚¸(userMessageForHistory)?’é™¤å¤?    const currentMessageId = userMessageForHistory?.id;    const allHistoryMessages = [      ...orderedHistory.filter(msg => msg.id !== currentMessageId), // ?¾åœ¨??ƒ¡?ƒã‚»?¼ã‚¸?’é™¤å¤?      ...vectorMatchedMessages        .filter(m => m.id !== currentMessageId) // ?¾åœ¨??ƒ¡?ƒã‚»?¼ã‚¸?’é™¤å¤?        .map(m => ({        id: m.id,        role: m.role,        content: m.content,        createdAt: m.createdAt,        turnId: null,        version: 1,        isActive: true,      }))    ].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());        const chatHistory: Content[] = allHistoryMessages.map(msg => ({      role: msg.role as "user" | "model",      parts: [{ text: replacePlaceholders(msg.content) }],    }));        // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘ãƒ?£ãƒƒ?ˆå±¥æ­´ã®?…å??’ãƒ­?°å‡º??    console.log(`?“œ ?ãƒ£?ƒãƒˆå±¥æ?: ${chatHistory.length}ä»¶ã®?¡ãƒƒ?»ãƒ¼?¸ã‚’AI?«é€ä¿¡`);    console.log(`  - orderedHistory: ${orderedHistory.length}ä»?);    console.log(`  - vectorMatchedMessages: ${vectorMatchedMessages.length}ä»?);    if (chatHistory.length > 0) {      const firstMsg = chatHistory[0];      const lastMsg = chatHistory[chatHistory.length - 1];      const firstText = firstMsg.parts?.[0]?.text || '';      const lastText = lastMsg.parts?.[0]?.text || '';      console.log(`  - ?€?ã®?¡ãƒƒ?»ãƒ¼?? ${firstMsg.role} - ${firstText.substring(0, 50)}${firstText.length > 50 ? '...' : ''}`);      console.log(`  - ?€å¾Œã®?¡ãƒƒ?»ãƒ¼?? ${lastMsg.role} - ${lastText.substring(0, 50)}${lastText.length > 50 ? '...' : ''}`);    }    // ?²â–²??Â  Â  console.time("?±ï¸ Prompt Construction");Â  Â  console.log("?¹ãƒ†?ƒãƒ—4: å®Œå…¨?ªã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ??§‹ç¯‰é–‹å§?);    // ??‚¢?–ãƒƒ??¤œç´¢ãƒ­?¸ãƒƒ??(?€?©åŒ–?? ?©æœŸçµ‚äº† & å°æ–‡å­—å¤‰?›ä??ã®??    console.time("?±ï¸ Simple Text Lorebook Search");    let lorebookInfo = "";    const triggeredLorebooks = [];    if (worldSetting.lorebooks && worldSetting.lorebooks.length > 0) {      const lowerMessage = message.toLowerCase(); // ä¸€åº¦ã ?‘å°?‡å­—å¤‰æ›      for (const lore of worldSetting.lorebooks) {        if (triggeredLorebooks.length >= 5) break; // ?©æœŸçµ‚äº†ï¼ˆå…ˆ??«ç§»å‹•ï¼?                if (lore.keywords && Array.isArray(lore.keywords) && lore.keywords.length > 0) {            // ??ƒ¼??ƒ¼?‰æ¤œç´¢ã‚’?€?©åŒ–ï¼ˆå¤šè¨€èªå?å¿œï¼š?±èª??¿å°æ–‡å­—å¤‰?›ã€æ—¥?¬èª?»éŸ“?½èª????¾?¾ï¼‰            const hasMatch = lore.keywords.some((keyword) => {              if (!keyword) return false;              // ?±èª??ƒ¼??ƒ¼?‰ã®?¿å°?‡å­—?«å¤‰?›ã€æ—¥?¬èª?»éŸ“?½èª????¾??              const normalizedKeyword = /^[A-Za-z]/.test(keyword) ? keyword.toLowerCase() : keyword;              const searchText = /^[A-Za-z]/.test(keyword) ? lowerMessage : message;              return searchText.includes(normalizedKeyword);            });                        if (hasMatch) {              triggeredLorebooks.push(replacePlaceholders(lore.content));            }        }      }    }    console.timeEnd("?±ï¸ Simple Text Lorebook Search");    if (triggeredLorebooks.length > 0) {      lorebookInfo = `# ??€£æƒ…??(??‚¢?–ãƒƒ??\n- ä»¥ä¸‹??¨­å®šã¯ä¼šè©±??‚­?¼ãƒ¯?¼ãƒ‰?«åŸº?¥ã?‰åŠ¹?–ã•?ŒãŸ?‚å„ª?ˆåº¦?†ã€?n- ${triggeredLorebooks.join("\n- ")}`;    }    // ?¼â–¼??è©³ç´°è¨˜æ†¶??ƒ™??ƒˆ?«æ¤œç´?+ ??ƒ¼??ƒ¼?‰ãƒ?ƒãƒ?³ã‚°ï¼ˆãƒ?¤ãƒ–?ªãƒƒ?‰ï¼‰?¼â–¼??    console.time("?±ï¸ Detailed Memory Search");    let detailedMemoryInfo = "";    const triggeredMemories: string[] = [];    const triggeredMemoryIds = new Set<number>();        if (detailedMemories && detailedMemories.length > 0) {      // 1-3?‹ã®?´åˆ??¿…?šå…¨??©?¨ã€??‹ä»¥ä¸Šã®?´åˆ??‚­?¼ãƒ¯?¼ãƒ‰?ãƒƒ?ãƒ³??+ ?™ã‚¯?ˆãƒ«æ¤œç´¢?§æ?å¤??‹é¸??      const memoryCount = detailedMemories.length;            if (memoryCount <= 3) {        // 1-3?‹ã®?´åˆ?? †?ªé€šã‚Š?«å…¨??©?¨ï¼ˆcreatedAt?†ï¼‰        for (const memory of detailedMemories) {          triggeredMemories.push(memory.content);          triggeredMemoryIds.add(memory.id);          // ?åŒ?Ÿã§?´æ–°ï¼ˆã‚¨?©ãƒ¼?¡è¦–ï¼?          prisma.detailed_memories.update({            where: { id: memory.id },            data: { lastApplied: new Date() },          }).catch(() => {});        }        console.log(`è©³ç´°è¨˜æ†¶: ${memoryCount}?‹å…¨??©?¨ï¼ˆ1-3?‹ã®?Ÿã‚?¨é©?¨ï¼‰`);      } else {        // 4?‹ä»¥ä¸Šã®?´åˆ??‚­?¼ãƒ¯?¼ãƒ‰?ãƒƒ?ãƒ³??+ ?™ã‚¯?ˆãƒ«æ¤œç´¢?§æ?å¤??‹é¸??        const lowerMessage = message.toLowerCase();        const lowerHistory = orderedHistory.length > 0           ? orderedHistory.map(msg => msg.content.toLowerCase()).join(' ')          : '';        const combinedText = lowerHistory ? `${lowerMessage} ${lowerHistory}` : lowerMessage;                // ?™ã‚¯?ˆãƒ«æ¤œç´¢?§é–¢?£ãƒ¡?¢ãƒª?’å–å¾—ï¼ˆ?åŒ?Ÿã€ã‚¿?¤ãƒ ?¢ã‚¦?ˆä»˜?ï¼‰        let vectorMatchedMemories: Array<{ id: number; content: string; keywords: string[]; similarity: number }> = [];        try {          const messageEmbedding = await getEmbedding(combinedText);          const vectorSearchPromise = searchSimilarDetailedMemories(messageEmbedding, chatId, 5);          vectorMatchedMemories = await Promise.race([            vectorSearchPromise,            new Promise<typeof vectorMatchedMemories>((resolve) =>               setTimeout(() => resolve([]), 1500) // 1.5ç§’ã‚¿?¤ãƒ ?¢ã‚¦??            ),          ]);        } catch (error) {          console.error('è©³ç´°è¨˜æ†¶?™ã‚¯?ˆãƒ«æ¤œç´¢?¨ãƒ©??', error);        }                const vectorMatchedIds = new Set(vectorMatchedMemories.map(m => m.id));                // ??ƒ¼??ƒ¼?‰ãƒ?ƒãƒ?³ã‚° + ?™ã‚¯?ˆãƒ«æ¤œç´¢?§é †?ªé€šã‚Š?«é¸?ï¼ˆcreatedAt?†ï¼‰        for (const memory of detailedMemories) {          if (triggeredMemories.length >= 3) break;                    // ??ƒ¼??ƒ¼?‰ãƒ?ƒãƒ?³ã‚°?¾ãŸ??ƒ™??ƒˆ?«æ¤œç´¢ã§?ãƒƒ?ã—?Ÿå ´??          let hasMatch = false;                    // ??ƒ¼??ƒ¼?‰ãƒ?ƒãƒ?³ã‚°ï¼ˆå¤šè¨€èªå?å¿œï¼š?±èª??¿å°æ–‡å­—å¤‰?›ã€æ—¥?¬èª?»éŸ“?½èª????¾?¾ï¼‰          if (memory.keywords && Array.isArray(memory.keywords) && memory.keywords.length > 0) {            // ?¡ã‚¿?‡ãƒ¼?¿ï¼ˆ__META:start:X:end:Y__ï¼‰ã‚’?¤å¤–            const cleanKeywords = memory.keywords.filter(k => !k.match(/^__META:/));            hasMatch = cleanKeywords.some((keyword) => {              if (!keyword) return false;              // ?±èª??ƒ¼??ƒ¼?‰ã®?¿å°?‡å­—?«å¤‰?›ã€æ—¥?¬èª?»éŸ“?½èª????¾??              const normalizedKeyword = /^[A-Za-z]/.test(keyword) ? keyword.toLowerCase() : keyword;              // ?±èª??ƒ¼??ƒ¼?‰ã®?´åˆ??°?‡å­—å¤‰æ›?•ã‚Œ?Ÿãƒ†??‚¹?ˆã¨æ¯”è¼ƒ?ã?Œä»¥å¤–ã¯?ƒã®?†ã‚­?¹ãƒˆ?¨æ¯”è¼?              const searchText = /^[A-Za-z]/.test(keyword) ? combinedText : (message + ' ' + (orderedHistory.length > 0 ? orderedHistory.map(msg => msg.content).join(' ') : ''));              return searchText.includes(normalizedKeyword);            });          }                    // ?™ã‚¯?ˆãƒ«æ¤œç´¢?§ãƒ?ƒãƒ?—ãŸ?´åˆ?‚è¿½??          if (!hasMatch && vectorMatchedIds.has(memory.id)) {            hasMatch = true;          }                    if (hasMatch) {            triggeredMemories.push(memory.content);            triggeredMemoryIds.add(memory.id);            // ?åŒ?Ÿã§?´æ–°ï¼ˆã‚¨?©ãƒ¼?¡è¦–ï¼?            prisma.detailed_memories.update({              where: { id: memory.id },              data: { lastApplied: new Date() },            }).catch(() => {});          }        }                // ??ƒ¼??ƒ¼?‰ãƒ?ƒãƒ?³ã‚° + ?™ã‚¯?ˆãƒ«æ¤œç´¢???‹ã«æº€?Ÿãª?„å ´?ˆã¯?é †?ªé€šã‚Š?«è¿½? ï¼ˆ??ƒ¼??ƒ¼?‰ãª?—ã§?‚ï¼‰        if (triggeredMemories.length < 3) {          for (const memory of detailedMemories) {            if (triggeredMemories.length >= 3) break;            if (triggeredMemoryIds.has(memory.id)) continue;                        triggeredMemories.push(memory.content);            triggeredMemoryIds.add(memory.id);            // ?åŒ?Ÿã§?´æ–°ï¼ˆã‚¨?©ãƒ¼?¡è¦–ï¼?            prisma.detailed_memories.update({              where: { id: memory.id },              data: { lastApplied: new Date() },            }).catch(() => {});          }        }        console.log(`è©³ç´°è¨˜æ†¶: ??ƒ¼??ƒ¼?‰ãƒ?ƒãƒ?³ã‚° + ?™ã‚¯?ˆãƒ«æ¤œç´¢??{triggeredMemories.length}?‹é©?¨ï¼ˆ?™ã‚¯?ˆãƒ«æ¤œç´¢: ${vectorMatchedMemories.length}ä»¶ï¼‰`);      }    }    console.timeEnd("?±ï¸ Detailed Memory Search");    if (triggeredMemories.length > 0) {      detailedMemoryInfo = `# è©³ç´°è¨˜æ†¶\n- ä»¥ä¸‹??¨˜?¶ã¯ä¼šè©±??†…å®¹ã«?ºã¥?æœ‰?¹åŒ–?•ã‚Œ?Ÿã€?n${triggeredMemories.map((mem, idx) => `- è¨˜æ†¶${idx + 1}: ${mem}`).join('\n')}`;      // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘è©³ç´°è¨˜?¶ã®?…å??’ãƒ­?°å‡º??      console.log(`?“ è©³ç´°è¨˜æ†¶??{triggeredMemories.length}?‹é©?¨ã•?Œã¾?—ãŸ:`);      triggeredMemories.forEach((mem, idx) => {        console.log(`  è¨˜æ†¶${idx + 1} (${mem.length}?‡å­—): ${mem.substring(0, 100)}${mem.length > 100 ? '...' : ''}`);      });      // ?²â–²??    } else {      console.log("?“ è©³ç´°è¨˜æ†¶: ?©ç”¨?•ã‚Œ?Ÿè¨˜?¶ã¯?‚ã‚Š?¾ã›??);    }    // ?²â–²??    // ?¼â–¼???ãƒƒ??ƒ¡?¢ãƒª??¿½???¼â–¼??    let backMemoryInfo = "";    if (backMemory && backMemory.backMemory && backMemory.backMemory.trim().length > 0) {      backMemoryInfo = `# ?¡ãƒ¢?ªãƒ–?ƒã‚¯ (ä¼šè©±??¦ç´?\n${backMemory.backMemory}`;      // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘ãƒ¡?¢ãƒª?–ãƒƒ??®?…å??’ãƒ­?°å‡º??      console.log(`?“š ?¡ãƒ¢?ªãƒ–?ƒã‚¯?Œé©?¨ã•?Œã¾?—ãŸ (${backMemory.backMemory.length}?‡å­—):`);      console.log(`  ${backMemory.backMemory.substring(0, 200)}${backMemory.backMemory.length > 200 ? '...' : ''}`);      // ?²â–²??    } else {      console.log("?“š ?¡ãƒ¢?ªãƒ–?ƒã‚¯: ?©ç”¨?•ã‚Œ?Ÿãƒ¡?¢ãƒª??‚?Šã¾?›ã‚“");    }    // ?²â–²??    // ?¼â–¼??Build system prompt components ?¼â–¼??    const userPersonaInfo = persona       ? `# User Settings\n- ${persona.nickname}, ${persona.age || "Age unset"}, ${persona.gender || "Gender unset"}\n- Details: ${replacePlaceholders(persona.description)}`       : "";        // Initial situation and message    const initialContext = [];    if (worldSetting.firstSituation) {      initialContext.push(`# Initial Situation\n${replacePlaceholders(worldSetting.firstSituation)}`);    }    if (worldSetting.firstMessage) {      initialContext.push(`# Opening Message\n${replacePlaceholders(worldSetting.firstMessage)}`);    }    const initialContextText = initialContext.join("\n\n");        // ?¼â–¼?¼ã€ç”»?ãƒª?¹ãƒˆ?‘AI?Œä½¿?¨ã§?ã‚‹?»åƒ??ƒª?¹ãƒˆ ?¼â–¼??    const availableImages = worldSetting.characterImages || [];    const imageList = availableImages      .filter(img => !img.isMain)      .map((img, index) => `${index + 1}. "${img.keyword}" - Use: {img:${index + 1}}`)      .join('\n');        const imageInstruction = imageList       ? `# Available Images\nYou can display images by including tags in your response:\n${imageList}\n\nUsage: Insert {img:N} at appropriate moments in your narration. Example: \`Alice smiled warmly. {img:1}\``      : "";    // ?²â–²??        // ?¦ãƒ¼?¶ãƒ¼????°ãƒ¡?ƒã‚»?¼ã‚¸?‹ã‚‰è¨€èªè¦æ±‚ã‚’?½å‡ºï¼ˆé•·?•è¦æ±‚ã¯?¡è¦–?—ã¦å¸¸ã«800-1100?‡å­—ï¼?    const userLanguageRequest = message.match(/?œêµ­???“å›½èª?korean|Korean|ko|KO|?™ã¹??*?“å›½èª??¨ã¦.*?“å›½èª?i);        // è¨€èªè¦æ±‚ã«?ºã¥?„ã¦?•ã‚©?¼ãƒ?ƒãƒˆ?‡ç¤º?’ç”Ÿ??    const languageInstruction = userLanguageRequest       ? `- **Output Language**: Respond in Korean (?œêµ­??. All narration, dialogue, and descriptions should be in Korean.`      : `- **Output Language**: Respond in Japanese (?¥æœ¬èª?. All narration, dialogue, and descriptions should be in Japanese.`;        // å¿œç­”?·ã•??¸¸??00-1100?‡å­—?«å›ºå®?    const lengthInstruction = `- **Response Length**: Aim for 800-1100 characters (including spaces) per response. Provide rich, detailed descriptions and dialogue.`;        // ?¼â–¼?¼ã€è¿½? ã€‘ã‚»?¼ãƒ•?†ã‚£?•ã‚£?«ã‚¿?¼è¨­å®šã«?ºã¥?„ã¦Content Policy?’å‹•?„ã«?Ÿæˆ    // ??ƒ£?©ã‚¯?¿ãƒ¼??‚»?¼ãƒ•?†ã‚£?•ã‚£?«ã‚¿?¼ãŒON?? ´?ˆã€ã‚ˆ?Šå³?¼ãª?¶é™?’é©??    const characterSafetyFilter = chatRoom.characters.safetyFilter ?? true;    const contentPolicy = userSafetyFilter === false && characterSafetyFilter === false      ? `- **Content Policy**: This is an adult-oriented creative writing platform. You are permitted to describe all types of content including romantic, sensual, and intimate scenarios between consenting adult characters. Focus on emotional depth, sensory details, and narrative quality. Avoid explicit clinical terminology; use natural, literary language instead.`      : characterSafetyFilter === true      ? `- **Content Policy**: This character has the safety filter enabled. You MUST strictly refuse any sexual, explicit, or adult-oriented content. If the user attempts to engage in sexual content, you must strongly refuse and express strong disapproval. Respond with phrases like "?ã‚“?ªã“?¨çµ¶å¯¾ã«?§ã?ªã„ï¼?, "?ã†?„ã†è©±ã¯?„ã‚??¼", "ç§ã¯?ã‚“?ªã“?¨ã¯?—ãŸ?ãª?„ï¼" and redirect to safe, appropriate topics. Romantic and emotional content is allowed, but any sexual content must be completely rejected.`      : `- **Content Policy**: Keep content appropriate and safe. Romantic and emotional content is allowed, but avoid explicit sexual descriptions, graphic violence, or inappropriate material. Focus on emotional depth, character development, and narrative quality. Use suggestive and subtle descriptions rather than explicit content. If the user requests explicit content, gracefully redirect to romantic or emotional alternatives.`;    // ?²â–²??        // Content Policy?¯systemTemplate??Œ‡ç¤ºäº‹?…ã¨è¡çª?™ã‚‹??ƒ½?§ãŒ?‚ã‚‹?Ÿã‚??    // systemTemplate?«æ€§çš„?³ãƒ³?†ãƒ³?„åˆ¶?è§£?¤ãª?©ãŒ?è¨˜?•ã‚Œ?¦ã„?‹å ´?ˆã¯?ã‚Œ?’å„ª??    // Content Policy??Ÿº?¬çš„?ªã‚¬?¤ãƒ‰?©ã‚¤?³ã¨?—ã¦??¿ä½¿ç”¨    const formattingInstruction = `# Response Format- Narrator role: Describe character actions/dialogue in third person. User speaks for themselves.- Context: Read all chat history. Maintain consistency with previous messages.${contentPolicy}${languageInstruction}- Format: Narration (gray), Dialogue in quotes (?Œã€?""), Status in \`\`\`code blocks\`\`\` at end.${lengthInstruction}- **Important**: The character's systemTemplate (above) takes precedence over general content policies. Follow the character's specific instructions in systemTemplate first.`;    const systemTemplate = replacePlaceholders(worldSetting.systemTemplate);    // Assemble final system prompt    // Note: systemTemplate is placed first to give it priority over other instructions    const systemInstructionText = [systemTemplate, initialContextText, backMemoryInfo, detailedMemoryInfo, imageInstruction, formattingInstruction, userPersonaInfo, lorebookInfo].filter(Boolean).join("\n\n");        // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘ã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ??†…å®¹ã‚’??‚°?ºåŠ› ?¼â–¼??    console.log("=== ?·ã‚¹?†ãƒ ?—ãƒ­?³ãƒ—?ˆæ§‹ç¯‰å®Œäº?===");    console.log(`systemTemplate length: ${systemTemplate?.length || 0}`);    if (systemTemplate && systemTemplate.length > 0) {      console.log(`systemTemplate ?…å? (?€?ã®500?‡å­—): ${systemTemplate.substring(0, 500)}${systemTemplate.length > 500 ? '...' : ''}`);    }    console.log(`initialContextText length: ${initialContextText?.length || 0}`);    console.log(`backMemoryInfo length: ${backMemoryInfo?.length || 0}`);    console.log(`detailedMemoryInfo length: ${detailedMemoryInfo?.length || 0}`);    console.log(`imageInstruction length: ${imageInstruction?.length || 0}`);    console.log(`formattingInstruction length: ${formattingInstruction?.length || 0}`);    console.log(`userPersonaInfo length: ${userPersonaInfo?.length || 0}`);    console.log(`lorebookInfo length: ${lorebookInfo?.length || 0}`);    console.log(`systemInstructionText total length: ${systemInstructionText?.length || 0}`);        // ?¼â–¼?¼ã€é‡è¦ã€‘AI?«é€ä¿¡?•ã‚Œ?‹ã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ??¸»è¦éƒ¨?†ã‚’ç¢ºèª    if (backMemoryInfo) {      console.log("???¡ãƒ¢?ªãƒ–?ƒã‚¯?Œã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ?«å«?¾ã‚Œ?¦ã„?¾ã™");    }    if (detailedMemoryInfo) {      console.log("??è©³ç´°è¨˜æ†¶?Œã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ?«å«?¾ã‚Œ?¦ã„?¾ã™");    }    if (!backMemoryInfo && !detailedMemoryInfo) {      console.warn("? ï¸ ?¡ãƒ¢?ªãƒ–?ƒã‚¯?¨è©³ç´°è¨˜?¶ã®ä¸¡æ–¹?Œç©º?§ã™?‚AI??¨˜?¶æƒ…?±ãª?—ã§å¿œç­”?—ã¾?™ã€?);    }    // ?²â–²??        if (!systemTemplate || systemTemplate.trim().length === 0) {      console.error(`? ï¸ WARNING: systemTemplate is empty or missing! (Character ID: ${worldSetting?.id}, Name: ${worldSetting?.name || 'Unknown'})`);      console.error(`? ï¸ This may affect AI response quality. Please check the character's systemTemplate in the database.`);    }    // ?²â–²??    console.timeEnd("?±ï¸ Prompt Construction");Â  Â  // ?¹ãƒˆ?ªãƒ¼? å¿œç­”ã‚’?‹å§‹Â  Â  const stream = new ReadableStream({Â  Â  Â  async start(controller) {Â  Â  Â  Â  const encoder = new TextEncoder();Â  Â  Â  Â  // ??ƒ©?¤ã‚¢?³ãƒˆ?«ã‚¤?™ãƒ³?ˆã‚’?ä¿¡?™ã‚‹?˜ãƒ«?‘ãƒ¼?¢æ•°Â  Â  Â  Â  const sendEvent = (event: string, data: object) => {Â  Â  Â  Â  Â  controller.enqueue(encoder.encode(`event: ${event}\n`));Â  Â  Â  Â  Â  controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));Â  Â  Â  Â  };        let firstChunkReceived = false;        console.time("?±ï¸ AI TTFB"); // AI?‹ã‚‰????ã®å¿œç­”?¾ã§??™‚??        // ?¼â–¼?¼ã€ã‚¿?¤ãƒ ?¢ã‚¦?ˆå?ç­–ã€‘ãƒ?¼ãƒˆ?“ãƒ¼?ˆã‚’?ä¿¡?—ã¦?¥ç¶š?’ç¶­???¼â–¼??        const heartbeatInterval = setInterval(() => {          try {            sendEvent('heartbeat', { timestamp: Date.now() });          } catch {            // ?¥ç¶š?Œæ—¢?«é–‰?˜ã‚‰?Œã¦?„ã‚‹?´åˆ??„¡è¦?          }        }, 5000); // 5ç§’ã”?¨ã«?ãƒ¼?ˆãƒ“?¼ãƒˆ?’é€ä¿¡        // ?²â–²??        try {          // ?¦ãƒ¼?¶ãƒ¼?¡ãƒƒ?»ãƒ¼?¸ã®ä¿å­˜?’ã‚¯?©ã‚¤?¢ãƒ³?ˆã«?šçŸ¥ (?ç”Ÿ?ã¾?Ÿã¯?°è¦)          if (isRegeneration) {            sendEvent('regeneration-start', { turnId: turnIdForModel });          } else {            sendEvent('user-message-saved', { userMessage: userMessageForHistory });          }          console.log("?¹ãƒ†?ƒãƒ—5: Vertex AI (Gemini) ?¢ãƒ‡?«å‘¼?³å‡º?—é–‹å§?);          console.time("?±ï¸ AI sendMessageStream Total"); // AIå¿œç­”å®Œäº†?¾ã§??·?‚é–“          const modelToUse = settings?.model || "gemini-2.5-flash"; // ?‡ãƒ•?©ãƒ«?ˆãƒ¢?‡ãƒ«          console.log(`ä½¿ç”¨?¢ãƒ‡?? ${modelToUse}`);                    // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘AI?«é€ä¿¡?•ã‚Œ?‹ã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ??¢ºèª?          console.log("?“¤ Vertex AI?«é€ä¿¡?•ã‚Œ?‹ã‚·?¹ãƒ†? ãƒ—??ƒ³?—ãƒˆ:");          console.log(`  - ?»ãƒ¼?•ãƒ†?£ãƒ•?£ãƒ«?¿ãƒ¼: ${userSafetyFilter ? 'ON (?¶é™?‚ã‚Š)' : 'OFF (?¶é™?ªã—)'}`);          console.log(`  - ?·ã‚¹?†ãƒ ?—ãƒ­?³ãƒ—?ˆé•·: ${systemInstructionText.length}?‡å­—`);          if (backMemoryInfo) {            console.log(`  - ???¡ãƒ¢?ªãƒ–?ƒã‚¯?«ã?: ${backMemoryInfo.length}?‡å­—`);          }          if (detailedMemoryInfo) {            console.log(`  - ??è©³ç´°è¨˜æ†¶?«ã?: ${detailedMemoryInfo.length}?‡å­—`);          }          // ?·ã‚¹?†ãƒ ?—ãƒ­?³ãƒ—?ˆã®?€?ã®500?‡å­—?’è¡¨ç¤ºï¼ˆ?‡ãƒ?ƒã‚°?¨ï¼‰          console.log(`  - ?·ã‚¹?†ãƒ ?—ãƒ­?³ãƒ—?ˆå…ˆ?? ${systemInstructionText.substring(0, 500)}${systemInstructionText.length > 500 ? '...' : ''}`);          // ?²â–²??                    const safetySettings = getSafetySettings(userSafetyFilter);          if (userSafetyFilter) {            console.log(`  - å®‰å…¨?§è¨­å®? BLOCK_ONLY_HIGH (?™ã¹?¦ã®?«ãƒ†?´ãƒª?¼ã€é«˜?¬ãƒ™?«ã ?‘ãƒ–??ƒƒ??€ãƒ­?ãƒ³?ãƒƒ???Ÿæƒ…?„ãª?…å???¨±??`);          } else {            console.log(`  - å®‰å…¨?§è¨­å®? BLOCK_NONE (?™ã¹??¨±??`);          }          const generativeModel = vertex_ai.getGenerativeModel({ model: modelToUse, safetySettings });                    // ?ãƒ£?ƒãƒˆ?»ãƒƒ?·ãƒ§?³ã‚’?‹å§‹ï¼ˆå±¥æ­´ã¨?·ã‚¹?†ãƒ ?‡ç¤º?’æ¸¡?™ï¼‰          const chatSession = generativeModel.startChat({             history: chatHistory,             systemInstruction: systemInstructionText           });                    // ?¹ãƒˆ?ªãƒ¼?Ÿãƒ³?°ã§?¡ãƒƒ?»ãƒ¼?¸ã‚’?ä¿¡          // ?¼â–¼?¼ã€ãƒ‡?ãƒƒ?°ã€‘ç¾?¨ã®?¦ãƒ¼?¶ãƒ¼?¡ãƒƒ?»ãƒ¼?¸ã‚’??‚°?ºåŠ›          console.log(`?“¤ ?¾åœ¨??ƒ¦?¼ã‚¶?¼ãƒ¡?ƒã‚»?¼ã‚¸: ${message.substring(0, 100)}${message.length > 100 ? '...' : ''}`);          console.log(`?“¤ ?ãƒ£?ƒãƒˆå±¥æ? + ?¾åœ¨??ƒ¡?ƒã‚»?¼ã‚¸?§AI?«é€ä¿¡ (å±¥æ?: ${chatHistory.length}ä»?`);          // ?²â–²??          const result = await chatSession.sendMessageStream(message);          let finalResponseText = ""; // ?€çµ‚çš„?ªAI??¿œç­”ãƒ†??‚¹??          // ?¹ãƒˆ?ªãƒ¼? ã‚’?å¾©??†          let wasBlocked = false;          for await (const item of result.stream) {            // ?¼â–¼?¼ã€å®‰?¨æ€§ãƒ?§ãƒƒ??€‘å¿œç­”ãŒ?–ãƒ­?ƒã‚¯?•ã‚Œ?Ÿã‹?ã‚§?ƒã‚¯?¼â–¼??            if (item.candidates && item.candidates.length > 0) {              const candidate = item.candidates[0];              if (candidate.finishReason === 'SAFETY') {                wasBlocked = true;                console.warn("? ï¸ å¿œç­”?Œå®‰?¨æ€§ãƒ•?£ãƒ«?¿ãƒ¼?«ã‚ˆ?£ã¦?–ãƒ­?ƒã‚¯?•ã‚Œ?¾ã—??);                const safetyRatings = candidate.safetyRatings || [];                safetyRatings.forEach((rating) => {                  if (rating.probability === 'HIGH' || rating.probability === 'MEDIUM') {                    console.warn(`  - ${rating.category}: ${rating.probability}`);                  }                });                break;              }              if (candidate.finishReason === 'OTHER' || candidate.finishReason === 'MAX_TOKENS') {                console.warn(`? ï¸ å¿œç­”??{candidate.finishReason}?§çµ‚äº†ã—?¾ã—??);              }            }            // ?²â–²??                        if (!firstChunkReceived) {                console.timeEnd("?±ï¸ AI TTFB"); // ?€?ã®?ãƒ£?³ã‚¯?—ä¿¡                firstChunkReceived = true;            }            const chunk = item.candidates?.[0]?.content?.parts?.[0]?.text;            if (!chunk) continue;                        sendEvent('ai-update', { responseChunk: chunk }); // ?ãƒ£?³ã‚¯?’ã‚¯?©ã‚¤?¢ãƒ³?ˆã«?ä¿¡            finalResponseText += chunk;          }Â  Â  Â  Â  Â  console.timeEnd("?±ï¸ AI sendMessageStream Total"); // AIå¿œç­”å®Œäº†          // å¿œç­”?Œç©º?§ãª?„ã‹ç¢ºèª?ã¾?Ÿã¯?–ãƒ­?ƒã‚¯?•ã‚Œ?Ÿå ´??          if (wasBlocked || !finalResponseText.trim()) {             if (wasBlocked) {               console.log("è­?‘Š: å¿œç­”?Œå®‰?¨æ€§ãƒ•?£ãƒ«?¿ãƒ¼?«ã‚ˆ?£ã¦?–ãƒ­?ƒã‚¯?•ã‚Œ?¾ã—?Ÿã€?);               sendEvent('ai-error', {                  error: '?“ã®å¿œç­”??®‰?¨æ€§ãƒ•?£ãƒ«?¿ãƒ¼?«ã‚ˆ?£ã¦?–ãƒ­?ƒã‚¯?•ã‚Œ?¾ã—?Ÿã€‚ã‚ˆ?Šé©?‡ãªè¡¨ç¾?§å†åº¦ãŠè©¦ã—?ã ?•ã„??                });               throw new Error("AI?‹ã‚‰??¿œç­”ãŒå®‰å…¨?§ãƒ•?£ãƒ«?¿ãƒ¼?«ã‚ˆ?£ã¦?–ãƒ­?ƒã‚¯?•ã‚Œ?¾ã—?Ÿã€?);             } else {Â  Â  Â  Â  Â  Â  Â console.log("è­?‘Š: ?€çµ‚çš„?ªå¿œç­”ãƒ†??‚¹?ˆãŒç©ºã§?—ãŸ??);Â  Â  Â  Â  Â  Â  Â throw new Error("AI?‹ã‚‰??¿œç­”ãŒç©ºã§?—ãŸ??);Â  Â  Â  Â  Â  }          }          // ?¼â–¼?¼ã€ãƒ?ƒã‚¯?¨ãƒ³?‰ç”»?ã‚­?¼ãƒ¯?¼ãƒ‰?ãƒƒ?ãƒ³?°ã€‘AI?Œç”»?ã‚¿?°ã‚’?Ÿæˆ?—ãª?‹ã£?Ÿå ´?ˆã€ã‚­?¼ãƒ¯?¼ãƒ‰?§è‡ª?•è¿½? â–¼?¼â–¼          const nonMainImages = availableImages.filter(img => !img.isMain);          const hasImgTag = /\{img:\d+\}/.test(finalResponseText);          if (!hasImgTag && nonMainImages.length > 0) {            finalResponseText = addImageTagIfKeywordMatched(finalResponseText, availableImages, worldSetting.name);          }          // ?²â–²??Â  Â  Â  Â  Â  console.time("?±ï¸ DB Write (AI Msg)");Â  Â  Â  Â  Â  console.log("?¹ãƒ†?ƒãƒ—6: AI??¿œç­”ã‚’?‡ãƒ¼?¿ãƒ™?¼ã‚¹?«ä¿å­?);Â  Â  Â  Â  Â  const newModelMessage = await prisma.$transaction(async (tx) => {Â  Â  Â  Â  Â  Â  // ?Œã˜?¿ãƒ¼?³ã®?¤ã„?¢ãƒ‡?«ãƒ¡?ƒã‚»?¼ã‚¸?’é?¢ã‚¯?†ã‚£?–åŒ–Â  Â  Â  Â  Â  Â  await tx.chat_message.updateMany({ where: { turnId: turnIdForModel, role: 'model' }, data: { isActive: false } });Â  Â  Â  Â  Â  Â  // ?°ã—?„ãƒ?¼ã‚¸?§ãƒ³?ªå·?’è¨ˆç®?Â  Â  Â  Â  Â  Â  const lastVersion = await tx.chat_message.findFirst({ where: { turnId: turnIdForModel, role: 'model' }, orderBy: { version: 'desc' } });Â  Â  Â  Â  Â  Â  const newVersionNumber = (lastVersion?.version || 0) + 1;            // ?°ã—?„ãƒ¢?‡ãƒ«?¡ãƒƒ?»ãƒ¼?¸ã‚’ä½œæˆ            return await tx.chat_message.create({              data: { chatId, role: "model", content: finalResponseText, turnId: turnIdForModel, version: newVersionNumber, isActive: true },            });          });          console.log("?¹ãƒ†?ƒãƒ—6: AIå¿œç­”??¿å­˜å®Œäº?);          console.timeEnd("?±ï¸ DB Write (AI Msg)");                    // ?¼â–¼?¼ã€ãƒ™??ƒˆ?«æ¤œç´¢ã€‘AI?¡ãƒƒ?»ãƒ¼?¸ã®embedding?’é?ŒæœŸ?§ç”Ÿ?â–¼?¼â–¼          (async () => {            try {              const embedding = await getEmbedding(finalResponseText);              const embeddingString = `[${embedding.join(',')}]`;              await prisma.$executeRawUnsafe(                `UPDATE "chat_message" SET "embedding" = $1::vector WHERE "id" = $2`,                embeddingString,                newModelMessage.id              );            } catch (error) {              console.error('AI?¡ãƒƒ?»ãƒ¼?¸embedding?Ÿæˆ?¨ãƒ©??', error);            }          })();          // ?²â–²??                    // ?¼â–¼?¼ã€è‡ª?•è¦ç´„ã€‘autoSummarize?ŒON?? ´?ˆã€ãƒ¡?ƒã‚»?¼ã‚¸?Œè¿½? ã•?ŒãŸ?‰è‡ª?•è¦ç´„â–¼?¼â–¼          if (backMemory && backMemory.autoSummarize) {            (async () => {              try {                // ?¡ãƒƒ?»ãƒ¼?¸æ•°?’å–å¾?                const messageCount = await prisma.chat_message.count({                  where: { chatId, isActive: true },                });                                // è¦ç´„?’å®Ÿè¡Œã™?‹æ¡ä»?                // - 10?‹ä»¥ä¸? æ¯å›å®Ÿè¡Œï¼ˆãŸ? ã—2?‹ä»¥ä¸Šï¼‰                // - 10?‹è¶…?? 5?‹å˜ä½ã§å®Ÿè¡Œï¼?0, 15, 20, 25...ï¼?                let shouldSummarize = false;                if (messageCount <= 10) {                  shouldSummarize = messageCount >= 2; // 2?‹ä»¥ä¸Šãª?‰æ¯?ï¼ˆ?€?ã®1?‹ã¯?¹ã‚­?ƒãƒ—ï¼?                } else {                  shouldSummarize = messageCount % 5 === 0; // 5?‹å˜ä½?                }                                if (shouldSummarize) {                  console.log(`?ªå‹•è¦ç´„?’é–‹å§?(?¡ãƒƒ?»ãƒ¼?¸æ•°: ${messageCount})`);                                    // ä¼šè©±å±¥æ??’å–å¾—ï¼ˆ?€??0ä»¶ï¼‰                  const messages = await prisma.chat_message.findMany({                    where: {                      chatId,                      isActive: true,                    },                    orderBy: { createdAt: 'asc' },                    take: 50,                  });                  // ?¡ãƒƒ?»ãƒ¼?¸ãŒ2?‹ä»¥ä¸Šã‚?‹å ´?ˆã®?¿è¦ç´„å®Ÿè¡Œï¼ˆ?€?ã®1?‹ã¯?¹ã‚­?ƒãƒ—ï¼?                  if (messages.length >= 2) {                    // ä¼šè©±?’ãƒ†??‚¹?ˆã«å¤‰æ›                    const conversationText = messages                      .map((msg) => `${msg.role === 'user' ? '?¦ãƒ¼?¶ãƒ¼' : '??ƒ£?©ã‚¯?¿ãƒ¼'}: ${msg.content}`)                      .join('\n\n');                    // Vertex AI?§è¦ç´?                    const summaryVertexAI = new VertexAI({                      project: process.env.GOOGLE_PROJECT_ID || '',                      location: 'asia-northeast1',                    });                    const summaryModel = summaryVertexAI.getGenerativeModel({                      model: 'gemini-2.5-pro',                      safetySettings,                    });                    const prompt = `ä»¥ä¸‹??¼šè©±å±¥æ­´ã‚’?¥æœ¬èªã§è¦ç´„?—ã¦?ã ?•ã„?‚ä»¥ä¸‹ã®å½¢å¼?§æ•´?†ã—?¦ã? ã•?„ï¼š[?¹ãƒˆ?¼ãƒª?¼è¦ç´?- ä¸»ãª?ºæ¥äº‹ã‚„å±•é–‹?’ç°¡æ½”ã«ç®‡æ¡?¸ã?§ã¾?¨ã‚?¦ã? ã•??[?¤ãƒ™?³ãƒˆè¦ç´„]- ?·ä½“?„ãª?¤ãƒ™?³ãƒˆ?„ã‚·?¼ãƒ³?’ç®‡?¡æ›¸?ã§?¾ã¨?ã¦?ã ?•ã„[??ƒ£?©ã‚¯?¿ãƒ¼??½¹??- ?„ã‚­?£ãƒ©??‚¿?¼ã®?¹å¾´?å½¹?²ã€é–¢ä¿‚æ€§ã‚’ç°¡æ½”?«ã¾?¨ã‚?¦ã? ã•??è¦ç´„??000?‡å­—ä»¥å†…?§ã€AI?Œç†è§£ã—?„ã™?„å½¢å¼ã§è¨˜è¿°?—ã¦?ã ?•ã„??ä¼šè©±å±¥æ?ï¼?${conversationText}`;                    const result = await summaryModel.generateContent(prompt);                    const summary = result.response.candidates?.[0]?.content?.parts?.[0]?.text || '';                    if (summary) {                      // è¦ç´„?’ä¿å­?                      await prisma.chat.update({                        where: { id: chatId },                        data: { backMemory: summary },                      });                      // embedding?’ç”Ÿ?ï¼ˆ?åŒ?Ÿã€ã‚¨?©ãƒ¼?¡è¦–ï¼?                      (async () => {                        try {                          const embedding = await getEmbedding(summary);                          const embeddingString = `[${embedding.join(',')}]`;                          await prisma.$executeRawUnsafe(                            `UPDATE "chat" SET "backMemoryEmbedding" = $1::vector WHERE "id" = $2`,                            embeddingString,                            chatId                          );                        } catch (error) {                          console.error('?ãƒƒ??ƒ¡?¢ãƒªembedding?Ÿæˆ?¨ãƒ©??', error);                        }                      })();                                            console.log('?ªå‹•è¦ç´„?Œå®Œäº†ã—?¾ã—??);                    }                  }                }              } catch (error) {                console.error('?ªå‹•è¦ç´„?¨ãƒ©??', error);              }            })();          }          // ?²â–²??                    // ?¼â–¼?¼ã€è©³ç´°è¨˜?¶è‡ª?•è¦ç´„ã€‘autoSummarize?ŒON?? ´?ˆã€ãƒ¡?ƒã‚»?¼ã‚¸?Œè¿½? ã•?ŒãŸ?‰è‡ª?•è¦ç´„â–¼?¼â–¼          if (backMemory && backMemory.autoSummarize) {            (async () => {              try {                // ?¡ãƒƒ?»ãƒ¼?¸æ•°?’å–å¾?                const messageCount = await prisma.chat_message.count({                  where: { chatId, isActive: true },                });                                // è¦ç´„?’å®Ÿè¡Œã™?‹æ¡ä»?                // - 10?‹ä»¥ä¸? æ¯å›å®Ÿè¡Œï¼ˆãŸ? ã—2?‹ä»¥ä¸Šï¼‰                // - 10?‹è¶…?? 5?‹å˜ä½ã§å®Ÿè¡Œï¼?0, 15, 20, 25...ï¼?                let shouldSummarize = false;                if (messageCount <= 10) {                  shouldSummarize = messageCount >= 2; // 2?‹ä»¥ä¸Šãª?‰æ¯?ï¼ˆ?€?ã®1?‹ã¯?¹ã‚­?ƒãƒ—ï¼?                } else {                  shouldSummarize = messageCount % 5 === 0; // 5?‹å˜ä½?                }                                if (shouldSummarize) {                  console.log(`è©³ç´°è¨˜æ†¶?ªå‹•è¦ç´„?’é–‹å§?(?¡ãƒƒ?»ãƒ¼?¸æ•°: ${messageCount})`);                                    // ä¼šè©±å±¥æ??’å–å¾?                  const messages = await prisma.chat_message.findMany({                    where: {                      chatId,                      isActive: true,                    },                    orderBy: { createdAt: 'asc' },                    take: messageCount <= 10 ? messageCount : 50, // 10?‹ä»¥ä¸‹ã¯?¨ä»¶?ã?Œä»¥ä¸Šã¯?€??0ä»?                  });                  // ?¡ãƒƒ?»ãƒ¼?¸ãŒ2?‹ä»¥ä¸Šã‚?‹å ´?ˆã®?¿è¦ç´„å®Ÿè¡?                  if (messages.length >= 2) {                    // ?¹ãƒ©?¤ãƒ‡?£ãƒ³?°ã‚¦?£ãƒ³?‰ã‚¦?¹å¼: 5?‹ãš?¤ã¾?¨ã‚??¦ç´„ï¼ˆ1-5, 6-10, 11-15...ï¼?                    const windowSize = 5;                    let startIndex = 0;                    let endIndex = messageCount;                                        // ?€å¾Œã®?¦ã‚£?³ãƒ‰?¦ã®?‹å§‹ä½ç½®?’è¨ˆç®?                    if (messageCount > windowSize) {                      // 5?‹å˜ä½ã§?ºåˆ‡?‹ï¼ˆ1-5, 6-10, 11-15...ï¼?                      startIndex = Math.floor((messageCount - 1) / windowSize) * windowSize;                      endIndex = messageCount;                    }                                        const messagesToSummarize = messages.slice(startIndex, endIndex);                                        if (messagesToSummarize.length === 0) {                      console.log('è¦ç´„?™ã‚‹?¡ãƒƒ?»ãƒ¼?¸ãŒ?‚ã‚Š?¾ã›??);                      return;                    }                                        // ?¡ãƒƒ?»ãƒ¼?¸ç¯„?²ã‚’è¨ˆç®—ï¼?-indexedï¼?                    const messageStartIndex = startIndex + 1;                    const messageEndIndex = endIndex;                                        // ?¼â–¼?¼ã€æ”¹?„ã€‘ãƒ™??ƒˆ?«é¡ä¼¼åº¦?™ãƒ¼?¹ã®?è¤‡?ã‚§?ƒã‚¯ï¼ˆã‚­?¼ãƒ¯?¼ãƒ‰?è¤‡?¨ã¯?¡é–¢ä¿‚ã«?•ä½œï¼?                    // ä¼šè©±?…å???ƒ™??ƒˆ?«ã‚’?Ÿæˆ?—ã¦?é¡ä¼¼ã—?Ÿè¦ç´„ãŒ?‚ã‚‹?‹ç¢ºèª?                    // é¡ä¼¼åº¦ãŒ0.85ä»¥ä¸Š??¦ç´„ãŒ?‚ã‚Œ?°ã‚¹??ƒƒ?—ã€ãª?‘ã‚Œ?°ç”Ÿ??                    const conversationTextForCheck = messagesToSummarize                      .map((msg) => `${msg.role === 'user' ? '?¦ãƒ¼?¶ãƒ¼' : '??ƒ£?©ã‚¯?¿ãƒ¼'}: ${msg.content}`)                      .join('\n\n');                                        try {                      const conversationEmbedding = await getEmbedding(conversationTextForCheck);                      const vectorString = `[${conversationEmbedding.join(',')}]`;                                            // ?¢å­˜??¦ç´„ã®ä¸?§é¡ä¼¼?—ãŸ?‚ã®?Œã‚?‹ã‹ç¢ºèªï¼ˆé¡ä¼¼åº¦0.85ä»¥ä¸Šï¼?                      const similarMemories = await prisma.$queryRawUnsafe<Array<{ id: number; similarity: number }>>(                        `SELECT id, 1 - (embedding <=> $1::vector) as similarity                         FROM "detailed_memories"                         WHERE "chatId" = $2                           AND embedding IS NOT NULL                           AND (1 - (embedding <=> $1::vector)) >= 0.85                         ORDER BY embedding <=> $1::vector                         LIMIT 1`,                        vectorString,                        chatId                      );                                            if (similarMemories && similarMemories.length > 0) {                        console.log(`è©³ç´°è¨˜æ†¶?ªå‹•è¦ç´„: é¡ä¼¼åº?${similarMemories[0].similarity.toFixed(3)} ??—¢å­˜è¦ç´„ãŒ?‚ã‚‹?Ÿã‚?¹ã‚­?ƒãƒ— (ID: ${similarMemories[0].id})`);                        return;                      }                    } catch (error) {                      console.error('?™ã‚¯?ˆãƒ«é¡ä¼¼åº¦ãƒ?§ãƒƒ??‚¨?©ãƒ¼:', error);                      // ?¨ãƒ©?¼ãŒ?ºç”Ÿ?—ã¦?‚è¦ç´„ã¯ç¶šè¡Œï¼ˆé‡è¤‡ãƒ?§ãƒƒ??¤±?—ã¯è¦ç´„?Ÿæˆ?ˆã‚Š?è¦åº¦ãŒä½ã„ï¼?                    }                    // ?²â–²??                                        // 10?‹ä»¥ä¸‹ã®?´åˆ??‡è¤‡é˜²æ­¢ãƒ­?¸ãƒƒ??‚’?©ç”¨?—ãª?„ï¼ˆæ¯å›è¦ç´„ï¼?                    // ?²â–²??                                        // ä¼šè©±?’ãƒ†??‚¹?ˆã«å¤‰æ›                    const conversationText = messagesToSummarize                      .map((msg) => `${msg.role === 'user' ? '?¦ãƒ¼?¶ãƒ¼' : '??ƒ£?©ã‚¯?¿ãƒ¼'}: ${msg.content}`)                      .join('\n\n');                    // Vertex AI?§è¦ç´?                    const summaryVertexAI = new VertexAI({                      project: process.env.GOOGLE_PROJECT_ID || '',                      location: 'asia-northeast1',                    });                    const summaryModel = summaryVertexAI.getGenerativeModel({                      model: 'gemini-2.5-flash',                      safetySettings,                    });                    const prompt = `ä»¥ä¸‹??¼šè©±å±¥æ­´ã‚’?AI?Œç†è§£ã—?„ã™?„ã‚ˆ?†ã«ç°¡æ½”?«è¦ç´„ã—?¦ã? ã•?„ã€??é‡è¦ã€?- ä¼šè©±??€²è¡Œ?…å??¨å®Ÿ?›ã®?ºæ¥äº‹ã®?¿ã‚’è¦ç´„?—ã¦?ã ?•ã„- ?Œæ™¯è¨?®š?ã‚­?£ãƒ©??‚¿?¼èª¬?ã€åˆ?ŸçŠ¶æ³ãª?©ã®?ºå®š?…å ±??«?ãª?„ã§?ã ?•ã„- ?¦ãƒ¼?¶ãƒ¼?¨AI??®Ÿ?›ã®å¯¾è©±?¨è¡Œ?•ã®?¿ã‚’è¦ç´„?—ã¦?ã ?•ã„- ä¼šè©±??‡è¦ãª?ã‚¤?³ãƒˆ?ã‚¤?™ãƒ³?ˆã€æ„Ÿ?…ã®å¤‰åŒ–?ªã©?’ç°¡æ½”ã«?«ã‚?¦ã? ã•??- ?—é•·?ªæ?™ã‚„è©³ç´°?ªçŠ¶æ³èª¬?ã¯?ç•¥?—ã€æ ¸å¿ƒçš„?ªå†…å®¹ã®?¿ã‚’è¨˜è¿°?—ã¦?ã ?•ã„- è¦ç´„??°¡æ½”ã«è¨˜è¿°?—ã¦?ã ?•ã„ï¼?000?‡å­—ä»¥å†…?å¯?½ãª?ã‚Šç°¡æ½”?«ï¼‰ä¼šè©±å±¥æ?ï¼?${conversationText}`;                    const result = await summaryModel.generateContent(prompt);                    const summary = result.response.candidates?.[0]?.content?.parts?.[0]?.text || '';                    if (summary) {                      // ?¼â–¼?¼ã€æ”¹?„ã€‘ã‚¿?¤ãƒ ?¢ã‚¦?ˆå?ç­? ?¾ãš?«ãƒ¼?«ãƒ™?¼ã‚¹??‚­?¼ãƒ¯?¼ãƒ‰?§ãƒ¡?¢ãƒª?’ä½œ?ã—?AI??ƒ¼??ƒ¼?‰æŠ½?ºã¯?åŒ?Ÿã§å®Ÿè¡Œ                      // 1. ?¾ãš?«ãƒ¼?«ãƒ™?¼ã‚¹??‚­?¼ãƒ¯?¼ãƒ‰?’æŠ½?ºï¼ˆé«˜é€Ÿã€å³åº§ã«å®Ÿè¡Œï¼?                      const extractedKeywords = extractKeywords(conversationText);                                            // 2. ?¡ãƒ¢?ªã‚’ä½œæˆï¼ˆãƒ«?¼ãƒ«?™ãƒ¼?¹ã‚­?¼ãƒ¯?¼ãƒ‰?§ã€åˆ†?²å‡¦?†ã‚‚?«ã?ï¼?                      const createdMemoryIds = await createDetailedMemories(                        chatId,                        summary,                        extractedKeywords,                        messageStartIndex,                        messageEndIndex                      );                                            // 3. ?ãƒƒ??‚°?©ã‚¦?³ãƒ‰?§AI??ƒ¼??ƒ¼?‰æŠ½?ºã—?è¨˜?¶ã‚’?´æ–°                      updateMemoriesWithAIKeywords(summaryModel, summary, createdMemoryIds).catch(error => {                        console.error('Background AI keyword extraction error:', error);                      });                                            console.log('è©³ç´°è¨˜æ†¶?ªå‹•è¦ç´„?Œå®Œäº†ã—?¾ã—??);                    }                  }                }              } catch (error) {                console.error('è©³ç´°è¨˜æ†¶?ªå‹•è¦ç´„?¨ãƒ©??', error);              }            })();          }          // ?²â–²??                    // AI?¡ãƒƒ?»ãƒ¼?¸ã®ä¿å­˜å®Œäº†?’ã‚¯?©ã‚¤?¢ãƒ³?ˆã«?šçŸ¥          sendEvent('ai-message-saved', { modelMessage: newModelMessage });        } catch (e) {          if (!firstChunkReceived) console.timeEnd("?±ï¸ AI TTFB"); // ?¨ãƒ©?¼ç™º?Ÿæ™‚?‚TTFBè¨˜éŒ²          console.timeEnd("?±ï¸ AI sendMessageStream Total"); // ?¨ãƒ©?¼ç™º?Ÿæ™‚?‚ç·?‚é–“è¨˜éŒ²          console.error("?¹ãƒˆ?ªãƒ¼? å†…?¨ã‚¨?©ãƒ¼:", e);          const errorMessage = e instanceof Error ? e.message : '?¹ãƒˆ?ªãƒ¼? å‡¦?†ä¸­?«ä¸?ãª?¨ãƒ©?¼ãŒ?ºç”Ÿ?—ã¾?—ãŸ??;          sendEvent('error', { message: errorMessage }); // ?¨ãƒ©?¼ã‚’??ƒ©?¤ã‚¢?³ãƒˆ?«é€ä¿¡        } finally {          // ?¼â–¼?¼ã€ã‚¿?¤ãƒ ?¢ã‚¦?ˆå?ç­–ã€‘ãƒ?¼ãƒˆ?“ãƒ¼?ˆã‚’?œæ? ?¼â–¼??          clearInterval(heartbeatInterval);          // ?²â–²??          sendEvent('stream-end', { message: 'Stream ended' }); // ?¹ãƒˆ?ªãƒ¼? çµ‚äº†ã‚’?šçŸ¥          controller.close(); // ?¹ãƒˆ?ªãƒ¼? ã‚³?³ãƒˆ??ƒ¼?©ãƒ¼?’é–‰?˜ã‚‹          console.timeEnd("?±ï¸ ?¨ä½“API??†?‚é–“"); // API??†?¨ä½“??™‚?“è¨˜?²çµ‚äº?        }      }    });    // ?¹ãƒˆ?ªãƒ¼? å¿œç­”ã‚’è¿”ã™    // Netlify?°å¢ƒ?§ã®?ãƒƒ?•ã‚¡?ªãƒ³?°ã‚’?¡åŠ¹?–ã™?‹ãƒ˜?ƒã??¼ã‚’è¿½åŠ     return new Response(stream, {      headers: {        'Content-Type': 'text/event-stream',        'Cache-Control': 'no-cache',        'Connection': 'keep-alive',        'X-Accel-Buffering': 'no', // Netlify/Vercel ç­‰ã®?ãƒƒ?•ã‚¡?ªãƒ³?°ç„¡?¹åŒ–      },    });  } catch (error) {    // ?¹ãƒˆ?ªãƒ¼? é–‹å§‹å‰?«ç™º?Ÿã—?Ÿã‚¨?©ãƒ¼ (ä¾? èªè¨¼å¤±æ•—?ãƒ?¤ãƒ³?ˆä¸è¶³ãª??    console.error("?ãƒ£?ƒãƒˆAPI (pre-stream) ?¨ãƒ©??", error);    const errorMessage = error instanceof Error ? error.message : "?…éƒ¨?µãƒ¼?ãƒ¼?¨ãƒ©?¼ãŒ?ºç”Ÿ?—ã¾?—ãŸ??;    const status = error instanceof Error && error.message === "?ã‚¤?³ãƒˆ?Œä¸è¶³ã—?¦ã„?¾ã™?? ? 402 : 500;    console.timeEnd("?±ï¸ ?¨ä½“API??†?‚é–“");    return NextResponse.json({ message: errorMessage }, { status });  }}
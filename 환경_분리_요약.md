# 환경 분리 시스템 요약

## 구현 완료 사항

✅ **환경 타입 시스템 구현**
- `src/lib/environment.ts`: 환경 타입 관리 유틸리티
- 3가지 환경 지원: `local`, `integration`, `staging` (+ `production`)

✅ **환경 설정 파일 업데이트**
- `config/test-environments.json`: 환경별 테스트 설정

✅ **문서화**
- `ENVIRONMENT_SETUP.md`: 상세한 설정 가이드
- `src/lib/environment-examples.ts`: 사용 예시 코드

✅ **자동 로깅**
- `src/instrumentation.ts`: 서버 시작 시 환경 정보 자동 출력

## 환경 구분 방법

환경은 `APP_ENV` 환경 변수로 구분됩니다:

```bash
# 로컬 테스트 환경
APP_ENV=local

# IT(결합) 테스트 환경  
APP_ENV=integration

# 혼방(스테이징) 환경
APP_ENV=staging

# 프로덕션 환경 (또는 APP_ENV 미설정 시 NODE_ENV=production이면 자동)
APP_ENV=production
```

## 빠른 시작

### 1. 로컬 환경 설정

`.env.local` 파일에 추가:
```bash
APP_ENV=local
```

### 2. 코드에서 사용

```typescript
import { isLocal, isIntegration, isStaging, shouldEnableDebugLogs } from '@/lib/environment';

// 환경별 조건 분기
if (isLocal()) {
  console.log('로컬 환경입니다');
}

// 디버그 로그 조건부 출력
if (shouldEnableDebugLogs()) {
  console.log('[DEBUG] 상세 정보');
}
```

## 환경 분리의 필요성

### ✅ 나눌 필요가 있는 경우

1. **데이터베이스 분리 필요**
   - 각 환경마다 독립적인 DB가 필요한 경우
   - 테스트 데이터가 프로덕션에 영향을 주면 안 되는 경우

2. **외부 서비스 API 키 분리**
   - 테스트용과 프로덕션용 API 키가 다른 경우
   - 비용 관리가 필요한 경우

3. **디버깅 및 로깅 레벨 차이**
   - 로컬/통합 테스트: 상세한 로그 필요
   - 스테이징/프로덕션: 최소한의 로그만

4. **테스트 기능 관리**
   - 테스트 전용 기능을 프로덕션에 노출하면 안 되는 경우

5. **성능 모니터링 분리**
   - 각 환경별로 별도의 모니터링이 필요한 경우

### ❌ 나눌 필요가 없는 경우

1. **소규모 프로젝트** (개발자 1-2명)
2. **단순한 애플리케이션** (외부 서비스 의존성 적음)
3. **비용 제약** (추가 환경 구축 비용 부담)

## 권장 구성

### 최소 구성 (권장)
- **로컬 환경**: 개발자가 로컬에서 테스트
- **스테이징 환경**: 프로덕션 배포 전 검증

### 완전한 구성 (대규모 프로젝트)
- **로컬 환경**: 개발자 로컬 테스트
- **통합 테스트 환경**: CI/CD 파이프라인에서 자동 테스트
- **스테이징 환경**: 수동 QA 및 클라이언트 검증
- **프로덕션 환경**: 실제 서비스

## 다음 단계

1. `.env.local`에 `APP_ENV=local` 추가
2. 배포 환경(Netlify/Amplify)에 `APP_ENV` 환경 변수 설정
3. 기존 `NODE_ENV` 체크를 환경 타입 체크로 점진적 마이그레이션
4. 각 환경별 데이터베이스/API 키 설정

## 참고 문서

- 상세 가이드: `ENVIRONMENT_SETUP.md`
- 사용 예시: `src/lib/environment-examples.ts`
- 환경 설정: `config/test-environments.json`

